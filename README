# Instrukcja kompilacji

## Stack

Aby skompilować i uruchomić program w trybie gry "Human vs AI" (gracz zaczyna grę) nalezy wykonać polecenia:

```
> stack build
> stack exec gomoku
```

# Instrukcja kompilacji i uruchomienia programu konkursowego

## Stack

Aby skompilować i uruchomić program w trybie konkursowym nalezy wykonać polecenia:


```
> stack build
> stack exec -- contest b <f1 >f2
> stack exec -- contest w >f1 <f2
```

Pliki binarne zbudowane przez `stack` znajdują się w katalogu: `.stack-work/install/x86_64-osx/lts-8.16/8.0.2/bin/contest`

# Opis

Pełen kod źródłowy dostępny pod adresem: https://github.com/tpaszun/gomoku

## Reprezentacja planszy (`Gomoku.BitBoard`, `Gomoku.BitBoardImpl`)

Plansza jest przechowywana jako wektor (`Data.Vector.Unboxed.Vector`) wszystkich lini planszy - poziomych, pionowych oraz przekątnych. Kazdy element wektora (`Word64`) zawiera pojedynczą linię. Pola w lini kodowane są przy uzyciu dwóch bitów na pole.

Motywacja konstrukcji planszy w postaci bitowej:
  - kopiowanie planszy po modyfikacji jako kopiowanie ciągłego bloku pamięci
  - dopasowywanie wzorców jako operacje bitowe (XOR, AND, SHIFT są operacjami wykonywanymi bardzo efektywnie przez CPU)
  - mozliwość uzycia "stream fusion" dla operacji przeglądania planszy

Dla polepszenia czytelności mozliwe jest dodanie konstrukcji w stylu `newtype Line = Line Word64`, `newtype Pattern = Pattern Word64`. Najprawdopodobniej nie będzie miało to wpływu na wydajność, gdyz kompilator GHC podczas kompilacji zamienia typy `newtype` na typy uzyte w definicji.

## Wzorce i dopasowywanie (`Gomoku.Patterns`, `Gomoku.PatternCache`, `Gomoku.PAtternMatching`)

Wzorce w postaci binarnej generowane są podczas pierwszego ich uzycia i cache'owane są w postaci wektora (`Data.Vector.Unboxed.Vector Word64`). Dopasowanie wzorca polega na odpowiednim przesunięciu bitowym lini oraz przycięciu (bitowy AND) lini i wykonaniu bitowego XORa - jezeli wzorzec jest identyczny z dopasowywaną sekcją lini to wynik będzie równy 0.

## Wykrywanie oczywistych ruchów

Program zawiera funkcje wykrywające oczywiste ruchy gracza:
  - ruch wygrywający (ułozenie pięciu kamieni)
  - ruch nie-przegrywający (zablokowanie ułozenia pięciu kamieni przez przeciwnika)
  - ruch wygrywający w następnej turze (ułozenie czterech kamieni w lini niebronionych na obu końcach, lub ułozenie przy pomocy jednego ruchu dwóch zwykłych czwórek)
  - ruch blokujący ruch przeciwnika wygrywający w następnej turze

## Konstrukcja drzew

### Drzewo najlepszego ruchu przeglądane algorytmem minimax (`Gomoku.AI`)

Program wykorzystuje algorytm minimax do przeglądania drzewa najlepszych ruchów. Do algorytmu minimax została dodana modyfikacja, która powoduje głębsze przeglądanie węzłów, które zawierają oczywisty ruch (jezeli funkcja min/max natrafi na węzeł z jednym potomkiem to nie dekrementuje licznika głębokości). Funkcja generująca drzewo najlepszych ruchów wykorzystuje funkcje znajdujące oczywiste ruchy do redukcji ilości generowanych gałęzi (nie generuje oczywiście złych gałęzi). Gałęzienie drzewa najlepszych ruchów wykorzystuje:
  - selekcję pól sąsiadujących z zajętymi polami w odległości co najwyzej dwóch pól
  - szybką estymatę wartości pola (wartość pola dla przeciwnika + wartość pola dla gracza) - bazującą na wiedzy, ze pole, które jest najlepsze dla przeciwnika to równiez pole, które jest najlepsze dla mnie.

### Drzewo sekwencji wygrywających zagrozeń (`Gomoku.ThreatSearch`)

Do programu dodałem funkcję generującą drzewo sekwencji zagrozeń które prowadzą do wygranej. To drzewo mozna przeglądać głębiej niz drzewo najlepszych ruchów przez co program jest silniejszy (o ile standardowy algorytm selekcji ruchów stworzy taki układ pionów na planszy, ze zawierają wygrywające sekwencje)

Program nie implementuje algorytmu "Threat Space Search" - natomiast zaimplementowane rozwiązanie jest zainspirowane materiałami dotyczącymi TSS.

# Mozliwe rozszerzenia programu:

- Zastosowanie lepszego algorytmu przeglądania drzewa najlepszych ruchów, np. alpha-beta pruning, negascout, proof-number search, etc.
- Modyfikacja funkcji ewaluacji ruchu/planszy
- Zaimplementowanie pełnego algorytmu Threat Space Search
- Optymalizacje wydajności po profilowaniu programu, np.
    - uzycie mutowalnej reprezentacji planszy podczas generowania drzew (mutacja planszy przy przechodzeniu głębiej oraz cofanie ruchów przy powrocie do korzenia) - niemutowalna reprezentacja pociąga za sobą konieczność kopiowania bloków pamięci całej planszy
    - zapisanie długości lini oraz wzorca w wartości `Word64` reprezentującej linię/wzorzec zamiast wyliczania przez osobne funkcje - SHIFT i AND mogą okazać się szybsze niz "function call"